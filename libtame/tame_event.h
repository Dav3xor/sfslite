
// -*-c++-*-
/* $Id$ */

#ifndef _LIBTAME_TAME_EVENT_H_
#define _LIBTAME_TAME_EVENT_H_

#include "refcnt.h"
#include "vec.h"
#include "init.h"
#include "async.h"
#include "tame_recycle.h"

struct nil_t {};

void tame_error (const char *loc, const char *msg);

// A set of references
template<class T1=nil_t, class T2=nil_t, class T3=nil_t, class T4=nil_t>
class refset_t {
public:
  refset_t (T1 &r1, T2 &r2, T3 &r3, T4 &r4) 
    :  _r1 (r1), _r2 (r2), _r3 (r3), _r4 (r4) {}
  refset_t (T1 &r1, T2 &r2, T3 &r3)
    : _r1 (r1), _r2 (r2), _r3 (r3), _r4 (_dummy) {}
  refset_t (T1 &r1, T2 &r2)
    : _r1 (r1), _r2 (r2), _r3 (_dummy), _r4 (_dummy) {}
  refset_t (T1 &r1)
    : _r1 (r1), _r2 (_dummy), _r3 (_dummy), _r4 (_dummy) {}
  refset_t ()
    : _r1 (_dummy), _r2 (_dummy), _r3 (_dummy), _r4 (_dummy) {}

  void assign (const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4) 
  { _r1 = v1; _r2 = v2; _r3 = v3; _r4 = v4; mark_assign (); }
  void assign (const T1 &v1, const T2 &v2, const T3 &v3)
  { _r1 = v1; _r2 = v2; _r3 = v3; mark_assign (); }
  void assign (const T1 &v1, const T2 &v2) 
  { _r1 = v1; _r2 = v2; mark_assign(); }
  void assign (const T1 &v1) { _r1 = v1; mark_assign(); }
  void assign () { mark_assign(); }

  void track_assignment () 
  { 
    if (_assign_flag)
      _assign_flag = ref_flag_t::alloc (false); 
  }

  inline void mark_assign ()
  {
    if (_assign_flag)
      _assign_flag->set (true);
  }

  inline bool was_assigned () const
  {
    return (_assign_flag && *_assign_flag);
  }

private:
  nil_t _dummy;

  T1 &_r1;
  T2 &_r2;
  T3 &_r3;
  T4 &_r4;

  ref_flag_ptr_t _assign_flag;
};

class cancelable_t {
public:
  cancelable_t () {}
  virtual void cancel () = 0 ;
  virtual ~cancelable_t () {}
  virtual void set_notify_on_cancel (cbv::ptr cb) = 0;
  virtual ref_flag_ptr_t toolateflag () = 0;
};

class event_action_t : public virtual refcount {
public:
  virtual void perform (bool reuse) = 0;
  virtual void clear() = 0;
  virtual ~event_action_t () {}
};

typedef ptr<event_action_t> event_action_ptr_t;

void callback_second_trigger (const char *loc);


/*
 * event's will expose two different interfaces; the first 
 * is that off a cancelable class, for which the methods are
 * here; the second is that of an sfs-style callback, which is
 * introduced in tame_event_ag.h (ag=AutoGenerated).
 */
class event_cancel_base_t : public cancelable_t {
public:
  event_cancel_base_t (const char *loc = NULL) :
    _loc (loc),
    _reuse (false),
    _cancelled (false) {}

  ~event_cancel_base_t ()
  {
    toolate_to_cancel ();
  }

  ref_flag_ptr_t toolateflag () 
  {
    if (!_tlf) 
      _tlf = ref_flag_t::alloc (false);
    return _tlf;
  }

  void cancel ()
  {
    _cancelled = true;
    if (_noc) {
      cbv c (_noc);
      _noc = NULL;
      (*c) ();
    }
  }

  void set_notify_on_cancel (cbv::ptr cb) { _noc = cb; }
  void set_reuse (bool b) { _reuse = b; }

  bool get_reuse () const { return _reuse; }

  void toolate_to_cancel ()
  {
    if (_tlf && !*_tlf)
      _tlf->set (true);
    if (_noc)
      _noc = NULL;
  }

protected:
  const char *const _loc;
  bool _reuse, _cancelled;
  ref_flag_ptr_t _tlf;
  cbv::ptr _noc;
};

/*
 * For generic events, combine the trigger() classes with
 * the semantics for cancelation here.  Not all events need
 * to inherit from event_generic_base_t, especially those that
 * will make optmizations (like event<>, generated for implicit
 * rendezvous, the most common type of event). This base class,
 * however, uses virtualed generic actions.
 */
template<class B1=nil_t, class B2=nil_t, class B3=nil_t>
class event_generic_base_t : public event_cancel_base_t
{
public:
  event_generic_base_t (ptr<event_action_t> a, refset_t<B1,B2,B3> rs, 
			const char *loc = NULL) : 
    event_cancel_base_t (loc),
    _action (a),
    _refset (rs) {}

  ~event_generic_base_t () { finish (); }

  void dotrig (const B1 &b1, const B2 &b2, const B3 &b3)
  { dotrig (false, b1, b2, b3); }


  // Must tune dotrig to accept the correct number of arguments
  void dotrig (bool legacy, const B1 &b1, const B2 &b2, const B3 &b3)
  {
    ptr<event_action_t> a = prepare_action (legacy);
    if (a) {
      _refset.assign (b1,b2,b3);
      a->perform (this->_reuse);
    }
  }

  ptr<event_action_t> prepare_action (bool legacy = false)
  {
    ptr<event_action_t> ret;

    if (!this->_cancelled) {

      // once a trigger happens on this, it can't be cancelled
      this->toolate_to_cancel ();

      ret = _action;
      if (!ret) {
	tame_error (this->_loc, "event triggered after deallocation");
      } else if (!this->_reuse) {
	_action = NULL;
      }
    }
    return ret;
  }

  void rawtrig ()
  {
    ptr<event_action_t> a = prepare_action ();
    if (a) {
      a->perform (this->_reuse);
    }
  }

  void finish ()
  {
    if (_action) {
      _action->clear();
      _action = NULL;
    }
  }

  const refset_t<B1,B2,B3> &refset () const { return _refset; }

private:
  ptr<event_action_t> _action;
  refset_t<B1,B2,B3> _refset;
};

// Specify 1 extra argument, that way we can do template specialization
// elsewhere.  We should never have an instatiated event class with
// 4 templated types, though.
template<class T1=nil_t, class T2=nil_t, class T3=nil_t, class T4=nil_t> 
class event;

template<class T1=nil_t, class T2=nil_t, class T3=nil_t>
class event_t {
public:
  typedef ref<event<T1,T2,T3> > ref;
  typedef ptr<event<T1,T2,T3> > ptr;
};


#ifdef WRAP_DEBUG
# define CALLBACK_ARGS(x) "???", x, x
# else
# define CALLBACK_ARGS(x)
#endif


#endif /* _LIBTAME_TAME_EVENT_H_ */
