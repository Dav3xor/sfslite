
// -*-c++-*-
/* $Id: tame.h 2077 2006-07-07 18:24:23Z max $ */

#ifndef _LIBTAME_CONNECTORS_H_
#define _LIBTAME_CONNECTORS_H_

#include "tame.h"

typedef enum { OUTCOME_SUCC = 0,
	       OUTCOME_TIMEDOUT = 1,
	       OUTCOME_CANCELLED = 2,
	       OUTCOME_SIGNALED = 3,
	       OUTCOME_DISCARDED = 4 } outcome_t;

inline bool valid_timeout (int s, int ns)
{
  return (s >= 0 && ns >= 0 && (s > 0 || ns > 0));
}

template<class T1=nil_t, class T2=nil_t, class T3=nil_t>
class connector_t {
public:

  connector_t () {}

  static typename event_t<T1,T2,T3>::ptr
  cnc (typename event_t<T1,T2,T3>::ref in, 
       cancelable_t *cobj,
       int to_s,
       int to_ns,
       outcome_t *ocp = NULL)
  {
    typename event_t<T1,T2,T3>::ptr  ncb;
    connector_t<T1,T2,T3> c;
    c.__cnc (&ncb, in, cobj, to_s, to_ns, ocp);
    return ncb;
  }

  static typename event_t<T1,T2,T3>::ptr
  sig (typename event_t<T1,T2,T3>::ref in, 
       vec<int> sigv,
       int *res,
       cancelable_t *cobj)
  {
    typename event_t<T1,T2,T3>::ptr  ncb;
    connector_t<T1,T2,T3> c;
    c.__sig (&ncb, in, sigv, res, cobj);
    return ncb;
  }

private:
  void __cnc (typename event_t<T1,T2,T3>::ptr *out, 
	      typename event_t<T1,T2,T3>::ref in, 
	      cancelable_t *c, 
	      int to_s, 
	      int to_ns,
	      outcome_t *ocp,
	      CLOSURE);

  void __sig (typename event_t<T1,T2,T3>::ptr *out, 
	      typename event_t<T1,T2,T3>::ref in, 
	      vec<int> sigs,
	      int *sigp,
	      cancelable_t *cobj, 
	      CLOSURE);

};

tamed template<class T1, class T2, class T3> void 
connector_t<T1,T2,T3>::__sig (typename event_t<T1,T2,T3>::ptr *out, 
			      typename event_t<T1,T2,T3>::ref in, 
			      vec<int> sigs,
			      int *sigp,
			      cancelable_t *cobj)
{
  tvars {
    rendezvous_t<int> rv (__FILE__, __LINE__);
    T1 t1;
    T2 t2;
    T3 t3;
    refset_t<T1,T2,T3> rs (t1, t2, t3);
    int i;
    int sig;
  }

  if (cobj) {
    cobj->set_notify_on_cancel (mkevent (rv, -1));
  }
  for (i = 0; i < sigs.size (); i++) {
    sigcb (sigs[i], mkevent (rv, sigs[i]));
  }
  rs.track_assignment ();
  *out = mkevent_rs (rs, rv, 0);

  (*out)->set_notify_on_cancel (mkevent (rv, -2));

  twait (rv, sig);

  for (i = 0; i < sigs.size (); i++) {
    sigcb (sigs[i], NULL);
  }

  if (sigp) *sigp = sig;
  in->rawtrig (rs.was_assigned (), t1, t2, t3);
  rv.cancel ();
}


tamed template<class T1, class T2, class T3> void 
connector_t<T1,T2,T3>::__cnc (typename event_t<T1,T2,T3>::ptr *out, 
			      typename event_t<T1,T2,T3>::ref in, 
			      cancelable_t *cobj, 
			      int to_s, 
			      int to_ns,
			      outcome_t *ocp)
{
  tvars {
    rendezvous_t<outcome_t> rv (__FILE__, __LINE__);
    T1 t1;
    T2 t2;
    T3 t3;
    outcome_t outc;
    timecb_t *tcb (NULL);
    refset_t<T1,T2,T3> rs (t1, t2, t3);
  }

  if (cobj) {
    cobj->set_notify_on_cancel (mkevent (rv, OUTCOME_CANCELLED)); 
  }

  if (valid_timeout (to_s, to_ns)) {
    tcb = delaycb (to_s, to_ns, mkevent (rv, OUTCOME_TIMEDOUT));
  }

  rs.track_assignment ();
  *out = mkevent_rs (rs, rv, OUTCOME_SUCC);
  (*out)->set_notify_on_cancel (mkevent (rv, OUTCOME_DISCARDED));

  twait (rv, outc);

  if (outc != OUTCOME_TIMEDOUT && tcb) {
    timecb_remove (tcb);
  }
  tcb = NULL;

  if (ocp) *ocp = outc;
  in->rawtrig (rs.was_assigned (), t1, t2, t3);
  rv.cancel ();
}

namespace connector {

  template<typename T1, typename T2, typename T3>
  ref<event<T1,T2,T3> >
  cnc (ref<event<T1,T2,T3> > in, cancelable_t *cobj, 
	outcome_t *ocp = NULL)
  {
    return connector_t<T1,T2,T3>::cnc (in, cobj, -1, -1, ocp);
  }

  template<typename T1, typename T2, typename T3>
  ref<event<T1,T2,T3> >
  cnc (ref<event<T1,T2,T3> > in, cancelable_t *cobj, int to_s, int to_ns,
	outcome_t *ocp = NULL)
  {
    return connector_t<T1,T2,T3>::cnc (in, cobj, to_s, to_ns, ocp);
  }

  template<typename T1, typename T2, typename T3>
  ref<event<T1,T2,T3> >
  timeout (ref<event<T1,T2,T3> > in, int to_s, int to_ns = 0, 
	   outcome_t *ocp = NULL)
  {
    return connector_t<T1,T2,T3>::cnc (in, NULL, to_s, to_ns, ocp);
  }

  template<typename T1, typename T2, typename T3>
  ref<event<T1,T2,T3> >
  sig (ref<event<T1,T2,T3> > in, vec<int> sigs, int *sigp = NULL,
       cancelable_t *cobj = NULL)
  {
    return connector_t<T1,T2,T3>::sig (in, sigs, sigp, cobj);
  }

};

#endif /* _LIBTAME_CONNECTORS_H_ */
