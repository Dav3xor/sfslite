// -*-c++-*-
#ifndef __TAME_REDUNDANT_H__
#define __TAME_REDUNDANT_H__

#include "async.h"
#include "tame.h"

/* MM: The redundant caller allows for placing a timer
 * on a tamed function call which will serve to place a 
 * timeout on that call, upon which we will spawn additional
 * tasks until one of the spawned tasks has returned.
 *  
 * This is useful if you have a multiple node system, where
 * many nodes are equivalent. You can dispatch a job on one, and
 * if it doesn't return fast enough, you can spawn on more and 
 * have them race. 
 */

template<typename ResultType, typename TaskType>
struct redundant_caller_t {

    redundant_caller_t(size_t delay) : m_delay(delay), m_ctask(0), m_timer(NULL) { }
    
    void operator()(typename event<ResultType>::ptr res_ev) {
        go(res_ev);
    }
    void operator+=(const TaskType& t) {
        m_tasks.push_back(t);
    }

protected:
    
    void go(typename event<ResultType>::ptr res_ev, CLOSURE);
    void timer_wrapper(CLOSURE); 
    void task_wrapper(TaskType task, CLOSURE);

    size_t m_delay;
    size_t m_ctask;
    vec<TaskType> m_tasks;
    timecb_t *m_timer;
    typename event<bool, ResultType>::ptr m_monitor;
};

//-----------------------------------------------------------------------------

tamed template<typename ResultType, typename TaskType>
void redundant_caller_t<ResultType, TaskType>::task_wrapper(TaskType task) {
    tvars { ResultType res; }
    twait { task(mkevent(res)); }
    m_monitor->trigger(false, res);
}

//-----------------------------------------------------------------------------

tamed template<typename ResultType, typename TaskType>
void redundant_caller_t<ResultType, TaskType>::timer_wrapper() {
    twait {
        m_timer = delaycb(m_delay, 0, mkevent());
    }
    m_timer = NULL;
    m_monitor->trigger(true, ResultType());
}

//-----------------------------------------------------------------------------

tamed template<typename ResultType, typename TaskType>
void redundant_caller_t<ResultType, TaskType>::go
    (typename event<ResultType>::ptr res_ev) {

    tvars {
        rendezvous_t<> rv(__FILE__, __LINE__);
        bool timer(false);
        ResultType result;
    }

    if (!m_tasks.size()) { res_ev->trigger(result); return; }

    m_monitor = mkevent(rv, timer, result);
    m_monitor->set_reuse(true);

    task_wrapper(m_tasks[m_ctask++]);
    timer_wrapper();
    while (true) {
        twait(rv);
        if (timer) {
            if (m_ctask < m_tasks.size()) {
                task_wrapper(m_tasks[m_ctask++]);
                timer_wrapper();
            } else {
            }
        } else {
            break;
        }
    }
    if (m_timer) {
        timecb_remove(m_timer);
    }
    res_ev->trigger(result);
}

#endif
