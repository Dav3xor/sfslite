Index: arpc/rpctypes.h
===================================================================
--- arpc/rpctypes.h	(revision 5414)
+++ arpc/rpctypes.h	(working copy)
@@ -385,116 +385,158 @@
     { return hash_bytes (a.base (), a.size ()); }
 };
 
+/* 
+ * Default dummy enter and exit functions
+ */
+template<class T> void rpc_enter_field (T &t, const char *f) {}
+template<class T> void rpc_exit_field (T &t, const char *f) {}
 
+
 /*
  * Default traversal functions
  */
 
 template<class T, class R, size_t n> inline bool
-rpc_traverse (T &t, array<R, n> &obj)
+rpc_traverse (T &t, array<R, n> &obj, const char *field = NULL) 
 {
   typedef typename array<R, n>::elm_t elm_t;
+  bool ret = true;
 
+  rpc_enter_field(t, field);
+
   elm_t *p = obj.base ();
   elm_t *e = obj.lim ();
-  while (p < e)
+  while (ret && p < e)
     if (!rpc_traverse (t, *p++))
-      return false;
-  return true;
+      ret = false;
+
+  rpc_exit_field (t, field);
+  return ret;
 }
 
 template<class T, class R, size_t n> inline bool
-rpc_traverse (T &t, rpc_vec<R, n> &obj)
+rpc_traverse (T &t, rpc_vec<R, n> &obj, const char *field = NULL)
 {
   typedef typename rpc_vec<R, n>::elm_t elm_t;
 
+  bool ret = true;
+  rpc_enter_field (t, field);
+
   u_int32_t size = obj.size ();
-  if (!rpc_traverse (t, size) || size > obj.maxsize)
-    return false;
-
-  if (size < obj.size ())
-    obj.setsize (size);
-  else if (size > obj.size ()) {
-    size_t maxreserve = 0x10000 / sizeof (elm_t);
-    maxreserve = min<size_t> (maxreserve, size);
-    if (obj.size () < maxreserve)
-      obj.reserve (maxreserve - obj.size ());
+  if (!rpc_traverse (t, size) || size > obj.maxsize) {
+    ret = false;
+  } else {
+    if (size < obj.size ())
+      obj.setsize (size);
+    else if (size > obj.size ()) {
+      size_t maxreserve = 0x10000 / sizeof (elm_t);
+      maxreserve = min<size_t> (maxreserve, size);
+      if (obj.size () < maxreserve)
+	obj.reserve (maxreserve - obj.size ());
+    }
+    
+    elm_t *p = obj.base ();
+    elm_t *e = obj.lim ();
+    while (ret && p < e)
+      if (!rpc_traverse (t, *p++))
+	ret = false;
+    for (size_t i = size - obj.size (); ret && i > 0; i--)
+      if (!rpc_traverse (t, obj.push_back ()))
+	ret = false;
   }
-
-  elm_t *p = obj.base ();
-  elm_t *e = obj.lim ();
-  while (p < e)
-    if (!rpc_traverse (t, *p++))
-      return false;
-  for (size_t i = size - obj.size (); i > 0; i--)
-    if (!rpc_traverse (t, obj.push_back ()))
-      return false;
-  return true;
+  rpc_exit_field (t, field);
+  return ret;
 }
-
+  
 template<class T, class R> inline bool
-rpc_traverse (T &t, rpc_ptr<R> &obj)
+rpc_traverse (T &t, rpc_ptr<R> &obj, const char *field = NULL)
 {
   bool nonnil = obj;
-  if (!rpc_traverse (t, nonnil))
-    return false;
-  if (nonnil)
-    return rpc_traverse (t, *obj.alloc ());
-  obj.clear ();
-  return true;
+  bool ret = true;
+  rpc_enter_field (t, field);
+  if (!rpc_traverse (t, nonnil)) {
+    ret = false;
+  } else if (nonnil) {
+    ret = rpc_traverse (t, *obj.alloc ());
+  } else {
+    obj.clear ();
+  }
+  rpc_exit_field (t, field);
+  return ret;
 }
 
 template<class T> inline bool
-rpc_traverse (T &t, bool &obj)
+rpc_traverse (T &t, bool &obj, const char *field = NULL)
 {
   u_int32_t val = obj;
-  if (!rpc_traverse (t, val))
-    return false;
-  obj = val;
-  return true;
+  bool ret = true;
+  rpc_enter_field (t, field);
+  if (!rpc_traverse (t, val)) {
+    ret = false;
+  } else {
+    obj = val;
+  }
+  rpc_exit_field (t, field);
+  return ret;
 }
 
 template<class T> inline bool
-rpc_traverse (T &t, u_int64_t &obj)
+rpc_traverse (T &t, u_int64_t &obj, const char *field = NULL)
 {
   u_int32_t hi = obj >> 32;
   u_int32_t lo = obj;
-  if (!rpc_traverse (t, hi) || !rpc_traverse (t, lo))
-    return false;
-  obj = u_int64_t (hi) << 32 | lo;
-  return true;
+  bool ret = true;
+  rpc_enter_field (t, field);
+  if (!rpc_traverse (t, hi) || !rpc_traverse (t, lo)) {
+    ret = false;
+  } else {
+    obj = u_int64_t (hi) << 32 | lo;
+  }
+  rpc_exit_field (t, field);
+  return ret;
 }
 
 template<class T> inline bool
-rpc_traverse (T &t, double &obj)
+rpc_traverse (T &t, double &obj, const char *field = NULL)
 {
   int64_t d = 100000000;
   double tmp = obj * d;
   int64_t n = int64_t (tmp);
-  if (!rpc_traverse (t, d) || !rpc_traverse (t, n))
-    return false; 
-  obj = (double)n / (double)d;
+  bool ret = true;
+  rpc_enter_field (t, field);
+  if (!rpc_traverse (t, d) || !rpc_traverse (t, n)) {
+    ret = false; 
+  } else {
+    obj = (double)n / (double)d;
+  }
+  rpc_exit_field (t, field);
   return true;
 }
 
 template<class T> inline bool
-rpc_traverse (T &t, int32_t &obj)
+rpc_traverse (T &t, int32_t &obj, const char *field = NULL)
 {
-  return rpc_traverse (t, reinterpret_cast<u_int32_t &> (obj));
+  rpc_enter_field (t, field);
+  bool ret = rpc_traverse (t, reinterpret_cast<u_int32_t &> (obj));
+  rpc_exit_field (t, field);
+  return ret;
 }
 
 template<class T> inline bool
-rpc_traverse (T &t, int64_t &obj)
+rpc_traverse (T &t, int64_t &obj, const char *field = NULL)
 {
-  return rpc_traverse (t, reinterpret_cast<u_int64_t &> (obj));
+  rpc_enter_field (t, field);
+  bool ret = rpc_traverse (t, reinterpret_cast<u_int64_t &> (obj));
+  rpc_exit_field (t, field);
+  return ret;
 }
 
-#define DUMBTRANS(T, type)			\
-inline bool					\
-rpc_traverse (T &, type &)			\
-{						\
-  return true;					\
-}
+#define DUMBTRANS(T, type)						\
+  inline bool								\
+  rpc_traverse (T &, type &, const char *f = NULL)			\
+  {									\
+    return true;							\
+  }
 
 #define DUMBTRAVERSE(T)				\
 DUMBTRANS(T, char)				\
@@ -530,51 +572,53 @@
 struct rpc_wipe_t : public rpc_clear_t {};
 extern struct rpc_wipe_t _rpcwipe;
 
+#define RPC_FIELD const char *field = NULL
+
 inline bool
-rpc_traverse (rpc_clear_t &, u_int32_t &obj)
+rpc_traverse (rpc_clear_t &, u_int32_t &obj, RPC_FIELD)
 {
   obj = 0;
   return true;
 }
 template<size_t n> inline bool
-rpc_traverse (rpc_clear_t &, rpc_opaque<n> &obj)
+rpc_traverse (rpc_clear_t &, rpc_opaque<n> &obj, RPC_FIELD)
 {
   bzero (obj.base (), obj.size ());
   return true;
 }
 template<size_t n> inline bool
-rpc_traverse (rpc_wipe_t &, rpc_opaque<n> &obj)
+rpc_traverse (rpc_wipe_t &, rpc_opaque<n> &obj, RPC_FIELD)
 {
   bzero (obj.base (), obj.size ());
   return true;
 }
 template<size_t n> inline bool
-rpc_traverse (rpc_clear_t &, rpc_bytes<n> &obj)
+rpc_traverse (rpc_clear_t &, rpc_bytes<n> &obj, RPC_FIELD)
 {
   obj.setsize (0);
   return true;
 }
 template<size_t n> inline bool
-rpc_traverse (rpc_wipe_t &, rpc_bytes<n> &obj)
+rpc_traverse (rpc_wipe_t &, rpc_bytes<n> &obj, RPC_FIELD)
 {
   bzero (obj.base (), obj.size ());
   obj.setsize (0);
   return true;
 }
 template<size_t n> inline bool
-rpc_traverse (rpc_clear_t &, rpc_str<n> &obj)
+rpc_traverse (rpc_clear_t &, rpc_str<n> &obj, RPC_FIELD)
 {
   obj = "";
   return true;
 }
 template<class T> inline bool
-rpc_traverse (rpc_clear_t &, rpc_ptr<T> &obj)
+rpc_traverse (rpc_clear_t &, rpc_ptr<T> &obj, RPC_FIELD)
 {
   obj.clear ();
   return true;
 }
 template<class T> inline bool
-rpc_traverse (rpc_wipe_t &t, rpc_ptr<T> &obj)
+rpc_traverse (rpc_wipe_t &t, rpc_ptr<T> &obj, RPC_FIELD)
 {
   if (obj)
     rpc_traverse (t, *obj);
@@ -582,13 +626,13 @@
   return true;
 }
 template<class T, size_t n> inline bool
-rpc_traverse (rpc_clear_t &, rpc_vec<T, n> &obj)
+rpc_traverse (rpc_clear_t &, rpc_vec<T, n> &obj, RPC_FIELD)
 {
   obj.setsize (0);
   return true;
 }
 template<class T, size_t n> inline bool
-rpc_traverse (rpc_wipe_t &t, rpc_vec<T, n> &obj)
+rpc_traverse (rpc_wipe_t &t, rpc_vec<T, n> &obj, RPC_FIELD)
 {
   for (typename rpc_vec<T, n>::elm_t *p = obj.base (); p < obj.lim (); p++)
     rpc_traverse (t, *p);
Index: arpc/xdrmisc.h
===================================================================
--- arpc/xdrmisc.h	(revision 5414)
+++ arpc/xdrmisc.h	(working copy)
@@ -189,7 +189,7 @@
 }
 
 inline bool
-rpc_traverse (XDR *xdrs, u_int32_t &obj)
+rpc_traverse (XDR *xdrs, u_int32_t &obj, RPC_FIELD)
 {
   switch (xdrs->x_op) {
   case XDR_ENCODE:
@@ -202,7 +202,7 @@
 }
 
 template<size_t n> inline bool
-rpc_traverse (XDR *xdrs, rpc_opaque<n> &obj)
+rpc_traverse (XDR *xdrs, rpc_opaque<n> &obj, RPC_FIELD)
 {
   switch (xdrs->x_op) {
   case XDR_ENCODE:
@@ -215,7 +215,7 @@
 }
 
 template<size_t max> inline bool
-rpc_traverse (XDR *xdrs, rpc_bytes<max> &obj)
+rpc_traverse (XDR *xdrs, rpc_bytes<max> &obj, RPC_FIELD)
 {
   switch (xdrs->x_op) {
   case XDR_ENCODE:
@@ -246,7 +246,7 @@
 }
 
 template<size_t max> inline bool
-rpc_traverse (XDR *xdrs, rpc_str<max> &obj)
+rpc_traverse (XDR *xdrs, rpc_str<max> &obj, RPC_FIELD)
 {
   switch (xdrs->x_op) {
   case XDR_ENCODE:
@@ -270,7 +270,7 @@
 }
 
 inline bool
-rpc_traverse (XDR *xdrs, str &obj)
+rpc_traverse (XDR *xdrs, str &obj, RPC_FIELD)
 {
   switch (xdrs->x_op) {
   case XDR_ENCODE:
Index: rpcc/genheader.C
===================================================================
--- rpcc/genheader.C	(revision 5414)
+++ rpcc/genheader.C	(working copy)
@@ -32,6 +32,8 @@
     XDR_RETURN " xdr_" << id << " (XDR *, void *);\n";
 }
 
+static const char *rpc_field = "const char *field = NULL";
+
 static str
 rpc_decltype (const rpc_decl *d)
 {
@@ -89,18 +91,25 @@
 
   aout << "\ntemplate<class T> "
        << (rs->decls.size () > 1 ? "" : "inline ") << "bool\n"
-       << "rpc_traverse (T &t, " << rs->id << " &obj)\n"
-       << "{\n";
+       << "rpc_traverse (T &t, " << rs->id << " &obj, " << rpc_field << ")\n"
+       << "{\n"
+       << "  bool ret = true;\n"
+       << "  rpc_enter_field (t, field);\n" ;
+
   const rpc_decl *rd = rs->decls.base ();
   if (rd < rs->decls.lim ()) {
-    aout << "  return rpc_traverse (t, obj." << (rd++)->id << ")";
-    while (rd < rs->decls.lim ())
-      aout << "\n    && rpc_traverse (t, obj." << (rd++)->id << ")";
+    aout << "  ret = rpc_traverse (t, obj." << rd->id 
+	 << ", \"" << rd->id << "\")";
+    rd++;
+    for ( ; rd < rs->decls.lim (); rd++ ) {
+      aout << "\n    && rpc_traverse (t, obj." << rd->id 
+	   << ", \"" << rd->id << "\")";
+    }
     aout << ";\n";
   }
-  else
-    aout << "  return true;\n";
-  aout << "}\n\n";
+  aout << "  rpc_exit_field (t, field);\n"
+       << "  return ret;\n"
+       << "}\n\n";
 }
 
 void
@@ -149,7 +158,8 @@
   if (rt->tag.type == "void")
     aout << prefix << "return true;\n";
   else
-    aout << prefix << "return rpc_traverse (t, *obj." << rt->tag.id << ");\n";
+    aout << prefix << "return rpc_traverse (t, *obj." << rt->tag.id 
+	 << ", \"" << rt->tag.id << "\");\n";
 }
 
 static void
@@ -242,7 +252,7 @@
   aout << "};\n";
 
   aout << "\ntemplate<class T> bool\n"
-       << "rpc_traverse (T &t, " << rs->id << " &obj)\n"
+       << "rpc_traverse (T &t, " << rs->id << " &obj, " << rpc_field << ")\n"
        << "{\n"
        << "  " << rs->tagtype << " tag = obj." << rs->tagid << ";\n"
        << "  if (!rpc_traverse (t, tag))\n"
@@ -256,7 +266,8 @@
        << "  return false;\n"
        << "}\n"
        << "inline bool\n"
-       << "rpc_traverse (const stompcast_t &s, " << rs->id << " &obj)\n"
+       << "rpc_traverse (const stompcast_t &s, " << rs->id << " &obj, "
+       << rpc_field << ")\n"
        << "{\n"
        << "  rpcunion_switch_" << rs->id << "\n"
        << "    (obj." << rs->tagid << ", RPCUNION_REC_STOMPCAST,\n"
@@ -301,7 +312,7 @@
   aout << "TYPE2STRUCT( , " << rs->id << ");\n";
 
   aout << "\ntemplate<class T> inline bool\n"
-       << "rpc_traverse (T &t, " << rs->id << " &obj)\n"
+       << "rpc_traverse (T &t, " << rs->id << " &obj, " << rpc_field << ")\n"
        << "{\n"
        << "  u_int32_t val = obj;\n"
        << "  if (!rpc_traverse (t, val))\n"
Index: crypt/bigint.h
===================================================================
--- crypt/bigint.h	(revision 5414)
+++ crypt/bigint.h	(working copy)
@@ -691,23 +691,23 @@
 
 #ifdef _ARPC_XDRMISC_H_
 inline bool
-rpc_traverse (XDR *xdrs, bigint &obj)
+rpc_traverse (XDR *xdrs, bigint &obj, RPC_FIELD)
 {
   return xdr_mpz_t (xdrs, &obj);
 }
 inline bool
-rpc_traverse (const stompcast_t, bigint &obj)
+rpc_traverse (const stompcast_t, bigint &obj, RPC_FIELD)
 {
   return true;
 }
 inline bool
-rpc_traverse (rpc_clear_t &, bigint &obj)
+rpc_traverse (rpc_clear_t &, bigint &obj, RPC_FIELD)
 {
   obj = 0;
   return true;
 }
 inline bool
-rpc_traverse (rpc_wipe_t &, bigint &obj)
+rpc_traverse (rpc_wipe_t &, bigint &obj, RPC_FIELD)
 {
   bigint zero (0);
   zero.swap (obj);
