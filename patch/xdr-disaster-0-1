Index: arpc/aclnt.C
===================================================================
--- arpc/aclnt.C	(revision 5416)
+++ arpc/aclnt.C	(working copy)
@@ -313,7 +313,7 @@
     warn ("failed to marshal auth crap\n");
     return false;
   }
-  if (!inproc (x.xdrp (), const_cast<void *> (in))) {
+  if (!inproc (x.vxdrp (), const_cast<void *> (in))) {
     warn ("arg marshaling failed (prog %d, vers %d, proc %d)\n",
 	  progno, versno, procno);
     return false;
Index: arpc/xdrmisc.C
===================================================================
--- arpc/xdrmisc.C	(revision 5416)
+++ arpc/xdrmisc.C	(working copy)
@@ -30,7 +30,7 @@
 const char __xdr_zero_bytes[4] = { 0, 0, 0, 0 };
 
 BOOL
-xdr_void (XDR *xdrs, void *)
+xdr_void (v_XDR_t *xdrs, void *)
 {
   return true;
 }
@@ -41,7 +41,7 @@
 }
 
 BOOL
-xdr_false (XDR *xdrs, void *)
+xdr_false (v_XDR_t *xdrs, void *)
 {
   return false;
 }
@@ -52,7 +52,7 @@
 }
 
 BOOL
-xdr_string (XDR *xdrs, void *objp)
+xdr_string (v_XDR_t *xdrs, void *objp)
 {
   return rpc_traverse (xdrs, *static_cast<rpc_str<RPC_INFINITY> *> (objp));
 }
@@ -63,7 +63,7 @@
 }
 
 BOOL
-xdr_int (XDR *xdrs, void *objp)
+xdr_int (v_XDR_t *xdrs, void *objp)
 {
   u_int32_t val;
   switch (xdrs->x_op) {
@@ -87,7 +87,7 @@
 
 #define DEFXDR(type)						\
 BOOL								\
-xdr_##type (XDR *xdrs, void *objp)				\
+xdr_##type (v_XDR_t *xdrs, void *objp)				\
 {								\
   return rpc_traverse (xdrs, *static_cast<type *> (objp));	\
 }								\
@@ -115,3 +115,30 @@
 RPC_PRINT_DEFINE(u_int32_t)
 RPC_PRINT_DEFINE(int64_t)
 RPC_PRINT_DEFINE(u_int64_t)
+
+//-----------------------------------------------------------------------
+
+v_XDR_t::~v_XDR_t ()
+{ 
+  s_tab.remove (&m_xdr);
+  XDR_DESTROY (implicit_cast<XDR *> (&m_xdr));
+}
+
+//-----------------------------------------------------------------------
+
+v_XDR_t::v_XDR_t () : m_vbit (-1) 
+{
+  s_tab.insert (&m_xdr, this);
+}
+
+//-----------------------------------------------------------------------
+
+v_XDR_t *
+v_XDR_t::upcast (XDR *in)
+{
+  v_XDR_t **ret = s_tab[in];
+  assert (ret);
+  return *ret;
+}
+
+//-----------------------------------------------------------------------
Index: arpc/asrv.C
===================================================================
--- arpc/asrv.C	(revision 5416)
+++ arpc/asrv.C	(working copy)
@@ -472,7 +472,7 @@
 
   const rpcgen_table *rtp = &s->tbl[sbp->proc ()];
   sbp->arg = s->tbl[sbp->proc ()].alloc_arg ();
-  if (!rtp->xdr_arg (x.xdrp (), sbp->arg)) {
+  if (!rtp->xdr_arg (x.vxdrp (), sbp->arg)) {
     if (asrvtrace >= 1)
       warn ("asrv::dispatch: bad message %s:%s x=%x", s->rpcprog->name,
 	    rtp->name, xidswap (m->rm_xid))
Index: arpc/rpctypes.h
===================================================================
--- arpc/rpctypes.h	(revision 5418)
+++ arpc/rpctypes.h	(working copy)
@@ -391,7 +391,14 @@
 template<class T> void rpc_enter_field (T &t, const char *f) {}
 template<class T> void rpc_exit_field (T &t, const char *f) {}
 
+inline void rpc_enter_field (v_XDR_t *x, const char *f) { x->enter_field (f); }
+inline void rpc_exit_field (v_XDR_t *x, const char *f) { x->exit_field (f); }
 
+template<class A> bool rpc_traverse (XDR *in, A &arg, const char *field = NULL)
+{
+  return rpc_traverse (v_XDR_t::upcast(in), arg, field);
+}
+
 /*
  * Default traversal functions
  */
Index: arpc/xdrmisc.h
===================================================================
--- arpc/xdrmisc.h	(revision 5418)
+++ arpc/xdrmisc.h	(working copy)
@@ -80,6 +80,26 @@
 namespace sfs {
   typedef BOOL (*xdrproc_t) (XDR *, void *);
 }
+
+class v_XDR_t {
+protected:
+  v_XDR_t (const v_XDR_t &);	// No copying
+  const v_XDR_t &operator= (const v_XDR_t &);
+  virtual void v_enter_field (const char *f) { m_vbit = 0; }
+  virtual void v_exit_field (const char *f) { m_vbit = 0; }
+public:
+  ~v_XDR_t ();
+  v_XDR_t ();
+  XDR *xdrp () { return &m_xdr; }
+  v_XDR_t *vxdrp () { return this; }
+  void enter_field (const char *f) { if (m_vbit != 0) v_enter_field (f); }
+  void exit_field (const char *f) { if (m_vbit != 0) v_exit_field (f); }
+  static v_XDR_t *upcast (XDR *in);
+private:
+  int m_vbit;
+  XDR m_xdr;
+};
+
 #include "rpctypes.h"
 
 #ifdef __APPLE__
@@ -189,107 +209,156 @@
 }
 
 inline bool
-rpc_traverse (XDR *xdrs, u_int32_t &obj, RPC_FIELD)
+rpc_traverse (v_XDR_t *vx, u_int32_t &obj, const char *field = NULL)
 {
+  bool ret = true;
+  rpc_enter_field (vx, field);
+  XDR *xdrs = vx->xdrp ();
   switch (xdrs->x_op) {
   case XDR_ENCODE:
-    return xdr_putint (xdrs, obj);
+    ret = xdr_putint (xdrs, obj);
+    break;
   case XDR_DECODE:
-    return xdr_getint (xdrs, obj);
+    ret = xdr_getint (xdrs, obj);
+    break;
   default:
-    return true;
+    ret = true;
+    break;
   }
+  rpc_exit_field (vx, field);
+  return ret;
 }
 
 template<size_t n> inline bool
-rpc_traverse (XDR *xdrs, rpc_opaque<n> &obj, RPC_FIELD)
+rpc_traverse (v_XDR_t *vx, rpc_opaque<n> &obj, const char *field = NULL)
 {
+  bool ret = true;
+  rpc_enter_field (vx, field);
+  XDR *xdrs = vx->xdrp ();
   switch (xdrs->x_op) {
   case XDR_ENCODE:
-    return xdr_putpadbytes (xdrs, obj.base (), obj.size ());
+    ret = xdr_putpadbytes (xdrs, obj.base (), obj.size ());
+    break;
   case XDR_DECODE:
-    return xdr_getpadbytes (xdrs, obj.base (), obj.size ());
+    ret = xdr_getpadbytes (xdrs, obj.base (), obj.size ());
+    break;
   default:
-    return true;
+    ret = true;
   }
+  rpc_exit_field (vx, field);
+  return ret;
 }
 
 template<size_t max> inline bool
-rpc_traverse (XDR *xdrs, rpc_bytes<max> &obj, RPC_FIELD)
+rpc_traverse (v_XDR_t *vx, rpc_bytes<max> &obj, const char *field = NULL)
 {
+  bool ret = true;
+  XDR *xdrs = vx->xdrp ();
+  rpc_enter_field (vx, field);
   switch (xdrs->x_op) {
   case XDR_ENCODE:
-    return xdr_putint (xdrs, obj.size ())
+    ret = xdr_putint (xdrs, obj.size ())
       && xdr_putpadbytes (xdrs, obj.base (), obj.size ());
+    break;
   case XDR_DECODE:
     {
       u_int32_t size;
-      if (!xdr_getint (xdrs, size) || size > obj.maxsize)
-	return false;
-      /* Assume XDR_INLINE works -- even though it could hypothetically
-       * fail for some types of XDR.  The alternative would be to use:
-       *    obj.setsize (size);
-       *    return xdr_getpadbytes (xdrs, obj.base (), size);
-       * however, then if size is garbage the program will die in
-       * obj.setsize (size) from trying to allocate too much memory.
-       */
-      char *dp = (char *) XDR_INLINE (xdrs, (size + 3) & ~3);
-      if (!dp)
-	return false;
-      obj.setsize (size);
-      sfs::memcpy_p (obj.base (), dp, size);
-      return true;
+      if (!xdr_getint (xdrs, size) || size > obj.maxsize) {
+	ret = false;
+      } else {
+	/* Assume XDR_INLINE works -- even though it could hypothetically
+	 * fail for some types of XDR.  The alternative would be to use:
+	 *    obj.setsize (size);
+	 *    return xdr_getpadbytes (xdrs, obj.base (), size);
+	 * however, then if size is garbage the program will die in
+	 * obj.setsize (size) from trying to allocate too much memory.
+	 */
+	char *dp = (char *) XDR_INLINE (xdrs, (size + 3) & ~3);
+	if (!dp) {
+	  ret = false;
+	} else {
+	  obj.setsize (size);
+	  sfs::memcpy_p (obj.base (), dp, size);
+	  ret = true;
+	}
+      }
     }
+    break;
   default:
-    return true;
+    ret = true;
   }
+  rpc_exit_field (vx, field);
+  return ret;
 }
 
 template<size_t max> inline bool
-rpc_traverse (XDR *xdrs, rpc_str<max> &obj, RPC_FIELD)
+rpc_traverse (v_XDR_t *xdrs, rpc_str<max> &obj, const char *field = NULL)
 {
+  bool ret = true;
+  rpc_enter_field (xdrs, field);
   switch (xdrs->x_op) {
   case XDR_ENCODE:
-    return obj && xdr_putint (xdrs, obj.len ())
+    ret = obj && xdr_putint (xdrs, obj.len ())
       && xdr_putpadbytes (xdrs, obj.cstr (), obj.len ());
+    break;
   case XDR_DECODE:
     {
       u_int32_t size;
-      if (!xdr_getint (xdrs, size) || size > max)
-	return false;
-      /* See comment for rpc_bytes */
-      char *dp = (char *) XDR_INLINE (xdrs, (size + 3) & ~3);
-      if (!dp || memchr (dp, '\0', size))
-	return false;
-      obj.setbuf (dp, size);
-      return true;
+      if (!xdr_getint (xdrs, size) || size > max) {
+	ret = false;
+      } else {
+	/* See comment for rpc_bytes */
+	char *dp = (char *) XDR_INLINE (xdrs, (size + 3) & ~3);
+	if (!dp || memchr (dp, '\0', size)) {
+	  ret = false;
+	} else {
+	  obj.setbuf (dp, size);
+	  ret = true;
+	}
+      }
     }
+    break;
   default:
-    return true;
+    ret = true;
+    break;
   }
+  rpc_exit_field (xdrs, field);
+  return ret;
 }
 
 inline bool
-rpc_traverse (XDR *xdrs, str &obj, RPC_FIELD)
+rpc_traverse (v_XDR_t *xdrs, str &obj, const char *field = NULL)
 {
+  bool ret = true;
+  rpc_enter_field (xdrs, field);
   switch (xdrs->x_op) {
   case XDR_ENCODE:
-    return obj && xdr_putint (xdrs, obj.len ())
+    ret = obj && xdr_putint (xdrs, obj.len ())
       && xdr_putpadbytes (xdrs, obj.cstr (), obj.len ());
+    break;
   case XDR_DECODE:
     {
       u_int32_t size;
-      if (!xdr_getint (xdrs, size))
-	return false;
-      mstr m (size);
-      if (!xdr_getpadbytes (xdrs, m, size) || memchr (m.cstr (), '\0', size))
-	return false;
-      obj = m;
+      if (!xdr_getint (xdrs, size)) {
+	ret = false;
+      } else {
+	mstr m (size);
+	if (!xdr_getpadbytes (xdrs, m, size) || 
+	    memchr (m.cstr (), '\0', size)) {
+	  ret = false;
+	} else {
+	  obj = m;
+	  ret = true;
+	}
+      }
     }
-    return true;
+    break;
   default:
-    return true;
+    ret = true;
+    break;
   }
+  rpc_exit_field (xdrs, field);
+  return ret;
 }
 
 template<class T> inline void
@@ -301,7 +370,7 @@
 inline void
 xdr_free (sfs::xdrproc_t proc, void *objp)
 {
-  XDR x;
+  v_XDR_t x;
   x.x_op = XDR_FREE;
   proc (&x, objp);
 }
@@ -325,9 +394,9 @@
   ~auto_xdr_delete () { xdr_delete (proc, objp); }
 };
 
-#define DECLXDR(type)				\
-extern BOOL xdr_##type (XDR *, void *);		\
-extern void *type##_alloc ();
+#define DECLXDR(type)					\
+  extern BOOL xdr_##type (v_XDR_t *, void *);		\
+  extern void *type##_alloc ();
 DECLXDR(void)
 DECLXDR(false)
 DECLXDR(string)
@@ -383,19 +452,9 @@
 #define RPCUNION_XXX_GCC40
 #endif /* not gcc 4 */
 
-class xdrbase : public XDR {
-protected:
-  xdrbase () {}
-  ~xdrbase () { XDR_DESTROY (implicit_cast<XDR *> (this)); }
-  xdrbase (const xdrbase &);	// No copying
-  const xdrbase &operator= (const xdrbase &);
-public:
-  XDR *xdrp () { return this; }
-};
-
 extern "C" void xdrsuio_create (XDR *, enum xdr_op);
 extern "C" void xdrsuio_scrub_create (XDR *, enum xdr_op);
-struct xdrsuio : xdrbase {
+struct xdrsuio : v_XDR_t {
   explicit xdrsuio (xdr_op op = XDR_ENCODE, bool scrub = false) {
     if (scrub)
       xdrsuio_scrub_create (this, op);
@@ -407,7 +466,7 @@
   u_int iovcnt ();
 };
 
-struct xdrmem : xdrbase {
+struct xdrmem : v_XDR_t {
   explicit xdrmem (char *base, size_t len, xdr_op op = XDR_DECODE)
     { xdrmem_create (this, base, len, op); }
   explicit xdrmem (const char *base, size_t len, xdr_op op = XDR_DECODE) {
@@ -421,7 +480,7 @@
 xdr2str (const T &t, bool scrub = false)
 {
   xdrsuio x (XDR_ENCODE, scrub);
-  XDR *xp = &x;
+  v_XDR_t *xp = &x;
   if (!rpc_traverse (xp, const_cast<T &> (t)))
     return NULL;
   mstr m (x.uio ()->resid ());
@@ -435,7 +494,7 @@
 str2xdr (T &t, const str &s)
 {
   xdrmem x (s, s.len ());
-  XDR *xp = &x;
+  v_XDR_t *xp = &x;
   return rpc_traverse (xp, t);
 }
 
@@ -443,7 +502,7 @@
 xdr2bytes (rpc_bytes<n> &out, const T &t, bool scrub = false)
 {
   xdrsuio x (XDR_ENCODE, scrub);
-  XDR *xp = &x;
+  v_XDR_t *xp = &x;
   if (!rpc_traverse (xp, const_cast<T &> (t)) || x.uio ()->resid () > n)
     return false;
   if (scrub)
@@ -457,7 +516,7 @@
 bytes2xdr (T &t, const rpc_bytes<n> &in)
 {
   xdrmem x (in.base (), in.size ());
-  XDR *xp = &x;
+  v_XDR_t *xp = &x;
   return rpc_traverse (xp, t);
 }
 
@@ -465,7 +524,7 @@
 buf2xdr (T &t, const void *buf, size_t len)
 {
   xdrmem x (reinterpret_cast<const char *> (buf), len);
-  XDR *xp = &x;
+  v_XDR_t *xp = &x;
   return rpc_traverse (xp, t);
 }
 
Index: rpcc/gencfile.C
===================================================================
--- rpcc/gencfile.C	(revision 5416)
+++ rpcc/gencfile.C	(working copy)
@@ -48,7 +48,7 @@
        << "  switch (xdrs->x_op) {\n"
        << "  case XDR_ENCODE:\n"
        << "  case XDR_DECODE:\n"
-       << "    return rpc_traverse (xdrs, *static_cast<"
+       << "    return rpc_traverse (v_XDR_t::upcast (xdrs), *static_cast<"
        << id << " *> (objp));\n"
        << "  case XDR_FREE:\n"
        << "    rpc_destruct (static_cast<" << id << " *> (objp));\n"
Index: crypt/crypthash.h
===================================================================
--- crypt/crypthash.h	(revision 5416)
+++ crypt/crypthash.h	(working copy)
@@ -63,7 +63,7 @@
 datasink_catxdr (datasink &dst, const T &t, bool scrub = false)
 {
   xdrsuio x (XDR_ENCODE, scrub);
-  XDR *xp = &x;
+  v_XDR_t *xp = &x;
   if (!rpc_traverse (xp, const_cast<T &> (t)))
     return false;
   for (const iovec *iov = x.iov (), *end = iov + x.iovcnt (); iov < end; iov++)
