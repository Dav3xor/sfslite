Index: arpc/xdrmisc.C
===================================================================
--- arpc/xdrmisc.C	(revision 5430)
+++ arpc/xdrmisc.C	(working copy)
@@ -115,3 +115,60 @@
 RPC_PRINT_DEFINE(u_int32_t)
 RPC_PRINT_DEFINE(int64_t)
 RPC_PRINT_DEFINE(u_int64_t)
+
+
+//=======================================================================
+
+ptr<v_XDR_dispatch_t> v_XDR_dispatch;
+
+//-----------------------------------------------------------------------
+
+v_XDR_t::~v_XDR_t () { m_dispatch->remove (m_x); }
+
+//-----------------------------------------------------------------------
+
+void v_XDR_dispatch_t::remove (XDR *x) 
+{ m_tab.remove (key (x)); }
+
+//-----------------------------------------------------------------------
+
+void v_XDR_dispatch_t::add (ptr<v_XDR_t> x) 
+{ m_tab.insert (key (x->xdrp ()), x); }
+
+//-----------------------------------------------------------------------
+
+ptr<v_XDR_t> v_XDR_dispatch_t::lookup (XDR *x)
+{ 
+  ptr<v_XDR_t> *retp, ret;
+  if ((retp = m_tab[key (x)])) {
+    ret = *retp;
+  }
+  return ret;
+}
+
+//-----------------------------------------------------------------------
+
+ptr<v_XDR_t> xdr_virtualize (XDR *x)
+{
+  ptr<v_XDR_t> ret;
+  if (v_XDR_dispatch) { ret = v_XDR_dispatch->lookup (x); }
+  return ret;
+}
+
+//-----------------------------------------------------------------------
+
+ptr<v_XDR_t> xdr_virtual_map (u_int32_t key, XDR *x)
+{
+  ptr<v_XDR_t> ret;
+  if (v_XDR_dispatch) {
+    ret = v_XDR_dispatch->alloc (key, x);
+  }
+  return ret;
+}
+
+//-----------------------------------------------------------------------
+
+uintptr_t v_XDR_dispatch_t::key (const XDR *v)
+{ return reinterpret_cast<uintptr_t> (v); }
+
+//=======================================================================
Index: arpc/asrv.C
===================================================================
--- arpc/asrv.C	(revision 5430)
+++ arpc/asrv.C	(working copy)
@@ -172,6 +172,9 @@
   get_rpc_stats ().end_call (this, ts_start);
 
   xdrsuio x (XDR_ENCODE);
+
+  ptr<v_XDR_t> vx = xdr_virtual_map (m_rpcvers, &x);
+
   if (!xdr_replymsg (x.xdrp (), &rm)) {
     warn ("svccb::reply: xdr_replymsg failed\n");
     delete this;
@@ -423,17 +426,22 @@
   xdrmem x (msg, len, XDR_DECODE);
   auto_ptr<svccb> sbp (New svccb);
   rpc_msg *m = &sbp->msg;
+  ptr<v_XDR_t> v_x;
+  u_int32_t rpcvers;
 
   if (!xdr_callmsg (x.xdrp (), m)) {
     trace (1) << "asrv::dispatch: xdr_callmsg failed\n";
     seteof (xi, src);
     return;
   }
-  if (m->rm_call.cb_rpcvers != RPC_MSG_VERSION) {
+
+  if ((rpcvers = m->rm_call.cb_rpcvers) != RPC_MSG_VERSION &&
+      !(v_x = xdr_virtual_map (rpcvers, &x))) {
     trace (1) << "asrv::dispatch: bad RPC message version\n";
     asrv_rpc_mismatch (xi, src, m->rm_xid);
     return;
   }
+  sbp->set_rpcvers (rpcvers);
 
   asrv *s = xi->stab[progvers (sbp->prog (), sbp->vers ())];
   if (!s || !s->cb) {
Index: arpc/xdrmisc.h
===================================================================
--- arpc/xdrmisc.h	(revision 5430)
+++ arpc/xdrmisc.h	(working copy)
@@ -487,4 +487,142 @@
   
 };
 
+//=======================================================================
+
+// support for virtual XDR handlers
+
+class v_XDR_dispatch_t;
+
+//------------------------------------------------------------
+
+// forward-declare this, which is in crypt.h
+class bigint;
+
+class v_XDR_t {
+public:
+  v_XDR_t (ptr<v_XDR_dispatch_t> d, XDR *x) : m_dispatch (d), m_x (x) {}
+  virtual ~v_XDR_t ();
+  XDR *xdrp () { return m_x; }
+  virtual bool rpc_traverse (u_int32_t &obj) = 0;
+  virtual bool rpc_traverse (u_int64_t &obj) = 0;
+  virtual bool rpc_encode (str s) = 0;
+  virtual bool rpc_decode (str *s) = 0;
+  virtual bool rpc_traverse (bigint &b) = 0;
+protected:
+  ptr<v_XDR_dispatch_t> m_dispatch;
+  XDR *m_x;
+};
+
+//------------------------------------------------------------
+
+class v_XDR_dispatch_t {
+public:
+  virtual ptr<v_XDR_t> alloc (u_int32_t rpcvers, XDR *input) = 0;
+  void remove (XDR *x);
+  void add (ptr<v_XDR_t> x);
+  ptr<v_XDR_t> lookup (XDR *x);
+protected:
+  static uintptr_t key (const XDR *v);
+  qhash<uintptr_t, ptr<v_XDR_t> > m_tab;
+};
+
+//------------------------------------------------------------
+
+ptr<v_XDR_t> xdr_virtualize (XDR *x);
+ptr<v_XDR_t> xdr_virtual_map (u_int32_t key, XDR *x);
+
+//------------------------------------------------------------
+
+extern ptr<v_XDR_dispatch_t> v_XDR_dispatch;
+
+//------------------------------------------------------------
+
+#define V_RPC_TRAV_2(T)							\
+  inline bool								\
+  rpc_traverse (ptr<v_XDR_t> x, T &obj, const char *field = NULL)	\
+  { return x->rpc_traverse (obj); }
+
+V_RPC_TRAV_2(u_int32_t)
+V_RPC_TRAV_2(u_int64_t)
+
+//-----------------------------------------------------------------------
+
+template<size_t n> inline bool
+rpc_traverse (ptr<v_XDR_t> x, rpc_opaque<n> &obj, const char *field = NULL)
+{
+  bool ret = false;
+  switch (x->xdrp ()->x_op) {
+  case XDR_ENCODE: 
+    {
+      mstr s (obj.size ());
+      memcpy (s.cstr (), obj.base (), obj.size ());
+      ret = x->rpc_encode (s);
+    }
+    break;
+  case XDR_DECODE:
+    {
+      str s;
+      if ((ret = x->rpc_decode (&s))) {
+	size_t len = min<size_t> (s.len (), n);
+	memcpy (obj.base (), s.cstr (), len);
+      }
+    }
+    break;
+  default:
+    break;
+  }
+  return ret;
+}
+
+//-----------------------------------------------------------------------
+
+template<size_t max> inline bool
+rpc_traverse (ptr<v_XDR_t> x, rpc_bytes<max> &obj, const char *field = NULL)
+{
+  bool ret = false;
+  switch (x->xdrp()->x_op) {
+  case XDR_ENCODE: 
+    {
+      mstr s (obj.size ());
+      memcpy (s.cstr (), obj.base(), obj.size ());
+      ret = x->rpc_encode (s);
+    }
+    break;
+  case XDR_DECODE:
+    {
+      str s;
+      if ((ret = x->rpc_decode (&s))) {
+	size_t len = min<size_t> (s.len (), max);
+	memcpy (obj.base (), s.cstr (), len);
+	obj.setsize (len);
+      }
+    }
+    break;
+  default:
+    break;
+  }
+  return ret;
+}
+
+//-----------------------------------------------------------------------
+
+template<size_t max> inline bool
+rpc_traverse (ptr<v_XDR_t> x, rpc_str<max> &obj, const char *field = NULL)
+{ 
+  bool ret = false;
+  switch (x->xdrp()->x_op) {
+  case XDR_ENCODE: 
+    ret = x->rpc_encode (obj);
+    break;
+  case XDR_DECODE:
+    ret = x->rpc_decode (&obj);
+    break;
+  default:
+    break;
+  }
+  return ret;
+}
+
+//=======================================================================
+
 #endif /* !_ARPC_XDRMISC_H_ */
Index: arpc/asrv.h
===================================================================
--- arpc/asrv.h	(revision 5430)
+++ arpc/asrv.h	(working copy)
@@ -62,6 +62,8 @@
 
   void init (asrv *, const sockaddr *);
 
+  u_int32_t m_rpcvers;
+
 protected:
   svccb ();
   virtual ~svccb ();
@@ -78,6 +80,7 @@
   u_int32_t prog () const { return msg.rm_call.cb_prog; }
   u_int32_t vers () const { return msg.rm_call.cb_vers; }
   u_int32_t proc () const { return msg.rm_call.cb_proc; }
+  void set_rpcvers (u_int32_t r) { m_rpcvers = r; }
 
   const ptr<asrv> &getsrv () const { return srv; }
 
Index: rpcc/gencfile.C
===================================================================
--- rpcc/gencfile.C	(revision 5430)
+++ rpcc/gencfile.C	(working copy)
@@ -48,8 +48,17 @@
        << "  switch (xdrs->x_op) {\n"
        << "  case XDR_ENCODE:\n"
        << "  case XDR_DECODE:\n"
-       << "    return rpc_traverse (xdrs, *static_cast<"
+       << "    {\n"
+       << "      ptr<v_XDR_t> v = xdr_virtualize (xdrs);\n"
+       << "      if (v) {\n"
+       << "        return rpc_traverse (v, *static_cast<"
        << id << " *> (objp));\n"
+       << "      } else {\n"
+       << "        return rpc_traverse (xdrs, *static_cast<"
+       << id << " *> (objp));\n"
+       << "      }\n"
+       << "    }\n"
+       << "    break;\n"
        << "  case XDR_FREE:\n"
        << "    rpc_destruct (static_cast<" << id << " *> (objp));\n"
        << "    return true;\n"
Index: patch/xdr_v_t-better-attempt-0-3
===================================================================
--- patch/xdr_v_t-better-attempt-0-3	(revision 5433)
+++ patch/xdr_v_t-better-attempt-0-3	(working copy)
@@ -105,7 +105,7 @@
 ===================================================================
 --- arpc/xdrmisc.h	(revision 5430)
 +++ arpc/xdrmisc.h	(working copy)
-@@ -487,4 +487,98 @@
+@@ -487,4 +487,142 @@
    
  };
  
@@ -126,6 +126,7 @@
 +  virtual ~v_XDR_t ();
 +  XDR *xdrp () { return m_x; }
 +  virtual bool rpc_traverse (u_int32_t &obj) = 0;
++  virtual bool rpc_traverse (u_int64_t &obj) = 0;
 +  virtual bool rpc_encode (str s) = 0;
 +  virtual bool rpc_decode (str *s) = 0;
 +  virtual bool rpc_traverse (bigint &b) = 0;
@@ -164,7 +165,9 @@
 +  { return x->rpc_traverse (obj); }
 +
 +V_RPC_TRAV_2(u_int32_t)
++V_RPC_TRAV_2(u_int64_t)
 +
++//-----------------------------------------------------------------------
 +
 +template<size_t n> inline bool
 +rpc_traverse (ptr<v_XDR_t> x, rpc_opaque<n> &obj, const char *field = NULL)
@@ -193,13 +196,54 @@
 +  return ret;
 +}
 +
++//-----------------------------------------------------------------------
++
 +template<size_t max> inline bool
 +rpc_traverse (ptr<v_XDR_t> x, rpc_bytes<max> &obj, const char *field = NULL)
-+{ return rpc_traverse (x->xdrp (), obj, field); }
++{
++  bool ret = false;
++  switch (x->xdrp()->x_op) {
++  case XDR_ENCODE: 
++    {
++      mstr s (obj.size ());
++      memcpy (s.cstr (), obj.base(), obj.size ());
++      ret = x->rpc_encode (s);
++    }
++    break;
++  case XDR_DECODE:
++    {
++      str s;
++      if ((ret = x->rpc_decode (&s))) {
++	size_t len = min<size_t> (s.len (), max);
++	memcpy (obj.base (), s.cstr (), len);
++	obj.setsize (len);
++      }
++    }
++    break;
++  default:
++    break;
++  }
++  return ret;
++}
 +
++//-----------------------------------------------------------------------
++
 +template<size_t max> inline bool
 +rpc_traverse (ptr<v_XDR_t> x, rpc_str<max> &obj, const char *field = NULL)
-+{ return rpc_traverse (x->xdrp (), obj, field); }
++{ 
++  bool ret = false;
++  switch (x->xdrp()->x_op) {
++  case XDR_ENCODE: 
++    ret = x->rpc_encode (obj);
++    break;
++  case XDR_DECODE:
++    ret = x->rpc_decode (&obj);
++    break;
++  default:
++    break;
++  }
++  return ret;
++}
 +
 +//=======================================================================
 +
@@ -248,107 +292,3 @@
         << "  case XDR_FREE:\n"
         << "    rpc_destruct (static_cast<" << id << " *> (objp));\n"
         << "    return true;\n"
-Index: patch/xdr_v_t-better-attempt-0-3
-===================================================================
---- patch/xdr_v_t-better-attempt-0-3	(revision 5432)
-+++ patch/xdr_v_t-better-attempt-0-3	(working copy)
-@@ -105,7 +105,7 @@
- ===================================================================
- --- arpc/xdrmisc.h	(revision 5430)
- +++ arpc/xdrmisc.h	(working copy)
--@@ -487,4 +487,68 @@
-+@@ -487,4 +487,98 @@
-    
-  };
-  
-@@ -117,11 +117,18 @@
- +
- +//------------------------------------------------------------
- +
-++// forward-declare this, which is in crypt.h
-++class bigint;
-++
- +class v_XDR_t {
- +public:
- +  v_XDR_t (ptr<v_XDR_dispatch_t> d, XDR *x) : m_dispatch (d), m_x (x) {}
- +  virtual ~v_XDR_t ();
- +  XDR *xdrp () { return m_x; }
-++  virtual bool rpc_traverse (u_int32_t &obj) = 0;
-++  virtual bool rpc_encode (str s) = 0;
-++  virtual bool rpc_decode (str *s) = 0;
-++  virtual bool rpc_traverse (bigint &b) = 0;
- +protected:
- +  ptr<v_XDR_dispatch_t> m_dispatch;
- +  XDR *m_x;
-@@ -154,14 +161,37 @@
- +#define V_RPC_TRAV_2(T)							\
- +  inline bool								\
- +  rpc_traverse (ptr<v_XDR_t> x, T &obj, const char *field = NULL)	\
--+  { return rpc_traverse (x->xdrp (), obj, field); }
-++  { return x->rpc_traverse (obj); }
- +
- +V_RPC_TRAV_2(u_int32_t)
- +
- +
- +template<size_t n> inline bool
- +rpc_traverse (ptr<v_XDR_t> x, rpc_opaque<n> &obj, const char *field = NULL)
--+{ return rpc_traverse (x->xdrp (), obj, field); }
-++{
-++  bool ret = false;
-++  switch (x->xdrp ()->x_op) {
-++  case XDR_ENCODE: 
-++    {
-++      mstr s (obj.size ());
-++      memcpy (s.cstr (), obj.base (), obj.size ());
-++      ret = x->rpc_encode (s);
-++    }
-++    break;
-++  case XDR_DECODE:
-++    {
-++      str s;
-++      if ((ret = x->rpc_decode (&s))) {
-++	size_t len = min<size_t> (s.len (), n);
-++	memcpy (obj.base (), s.cstr (), len);
-++      }
-++    }
-++    break;
-++  default:
-++    break;
-++  }
-++  return ret;
-++}
- +
- +template<size_t max> inline bool
- +rpc_traverse (ptr<v_XDR_t> x, rpc_bytes<max> &obj, const char *field = NULL)
-@@ -218,17 +248,3 @@
-         << "  case XDR_FREE:\n"
-         << "    rpc_destruct (static_cast<" << id << " *> (objp));\n"
-         << "    return true;\n"
--Index: crypt/bigint.h
--===================================================================
----- crypt/bigint.h	(revision 5430)
--+++ crypt/bigint.h	(working copy)
--@@ -695,6 +695,9 @@
-- {
--   return xdr_mpz_t (xdrs, &obj);
-- }
--+
--+V_RPC_TRAV_2(bigint)
--+
-- inline bool
-- rpc_traverse (const stompcast_t, bigint &obj, RPC_FIELD)
-- {
-Index: crypt/bigint.h
-===================================================================
---- crypt/bigint.h	(revision 5430)
-+++ crypt/bigint.h	(working copy)
-@@ -695,6 +695,9 @@
- {
-   return xdr_mpz_t (xdrs, &obj);
- }
-+
-+V_RPC_TRAV_2(bigint)
-+
- inline bool
- rpc_traverse (const stompcast_t, bigint &obj, RPC_FIELD)
- {
Index: crypt/bigint.h
===================================================================
--- crypt/bigint.h	(revision 5430)
+++ crypt/bigint.h	(working copy)
@@ -695,6 +695,9 @@
 {
   return xdr_mpz_t (xdrs, &obj);
 }
+
+V_RPC_TRAV_2(bigint)
+
 inline bool
 rpc_traverse (const stompcast_t, bigint &obj, RPC_FIELD)
 {
